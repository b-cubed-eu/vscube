---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup-dev, include=FALSE}
# library
library(vscube)
```


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Virtual Suitability Cube
<!-- badges: start --> <!-- badges: end -->

**Species suitability** refers to how favorable an environment is for a species to survive, reproduce, and grow in a specific area and time. It takes into account factors like climate, landscape, and resource availability.

Species Distribution Models (**SDMs**) are tools that use environmental and species occurrence data to study and predict the distribution of species across time and space. SDMs help identify suitable habitats, forecast the movements of invasive species, and illustrate how species distributions might change due to factors like climate change. 

To facilitate the observation of suitability for multiple species over time and space, we developed a framework that uses **Data Cubes**, multidimensional arrays that organize data in a structured way. The goal of `vscube` is to outline the steps to create a stars object, which includes three dimensions: **time**, **space** (represented as grid cells), and **species**, with suitability as the main attribute. Stars objects can be sliced, aggregated along one of the dimensions, and analyzed, making them ideal for studying species suitability.

``` {r}
# install.packages("remotes")
# remotes::install_github("b-cubed-eu/vscube")

``` 

## Download WorldClim predictors for May (Netherlands)

The function `vsc_build_worldclim()` automatically downloads monthly climatic variables from *WorldClim*, builds a `stars` data cube for all 12 months, and extracts a `SpatRaster` with the selected month’s layers.
It returns a list with three elements:

* `$stars`: a `stars` cube with all variables and all months

* `$predictors`: a `SpatRaster` with the selected month’s layers

* `$vars_kept`: a character vector with the successfully downloaded variables

In this example we build May (`month = 5`) climatic predictors for the Netherlands (`"NLD"`).

```  {r, echo = TRUE, warning = FALSE, message = FALSE}
# load packages 
library(vscube)
library(terra)
library(stars)
library(ggplot2)
library(viridis)
```

``` {r, echo = TRUE}
# Build climatic data for the Netherlands, May
cl_nld <- vsc_build_worldclim(iso3 = "NLD", month = 5)

# The function returns a list with three components:
str(cl_nld, max.level = 1)
```

``` {r, echo = TRUE}
# Show which variables were successfully downloaded
cl_nld$vars_kept
``` 

### First output: SpatRaster with predictors

```{r plot-predictors, eval=TRUE, echo=TRUE, fig.width=6, fig.height=5}
terra::plot(cl_nld$predictors, col = viridis(100))
```

``` {r, echo = TRUE}
# Basic info about the predictors
cl_nld$predictors
names(cl_nld$predictors)
terra::nlyr(cl_nld$predictors)
terra::ext(cl_nld$predictors)
terra::crs(cl_nld$predictors)
``` 

``` {r, echo = TRUE, eval = TRUE}
# convert SpatRaster to data frame for ggplot
df_tmin <- terra::as.data.frame(cl_nld$predictors[["tmin"]], xy = TRUE, na.rm = TRUE)

ggplot(df_tmin, aes(x, y, fill = tmin)) +
 geom_raster() +
 coord_equal() +
 scale_fill_viridis_c(name = "°C", option = "viridis") +
 labs(title = "Minimum temperature (tmin) — May, Netherlands",
 x = NULL, y = NULL) +
 theme_minimal(base_size = 12) +
 theme(panel.grid = element_blank())
``` 

### Second output: stars data cube 

A `stars` Data Cube with predictors as attributes and x, y, t as dimensions

``` {r, echo = TRUE, eval = TRUE}
# The full stars cube contains all 12 months for each variable
cl_nld$stars

# Dimensions and attribute names
st_dimensions(cl_nld$stars)
names(cl_nld$stars)
``` 

## Read and prepare occurrences

Together with climatic predictors, occurrences are needed: `vsc_read_occurrences()` ingests a GBIF TSV/TXT and returns a cleaned data frame with the key columns (`scientificName`, `decimalLatitude`, `decimalLongitude`, `year`) filtered by year range and removing NAs.

``` {r, echo = TRUE, eval = TRUE}
occ <- vsc_read_occurrences(
  example_file(),
  year_min = 2000,
  year_max = 2010
  )
head(occ)
``` 

The example contains 5 species of flowers in Flanders. 

## Split occurrences by species

After reading and cleaning the GBIF dataset with `vsc_read_occurrences()`, we can divide it into separate species datasets using `split_species_data()`.
This creates a list of data frames, one per species, that will be used in model training.

``` {r, echo = TRUE, eval = TRUE}
# split the data by species name
sp_list <- split_species_data(occ)

# show list summary
length(sp_list)
names(sp_list)

``` 

## Train SDMs (MaxEnt) for multiple species

The function `vsc_create_sdm_for_species_list()` trains a MaxEnt model for each species in your list (the output of `split_species_data()`), using a common stack of environmental predictors (e.g., the May predictors you built with `vsc_build_worldclim()`).

The function: 

* Cleans points (removes NAs, off-grid cells, duplicates per raster cell).

* Samples background points.

* Trains MaxEnt via `enmSdmX::trainMaxEnt()` for each species.

Returns a list with:

* `$models`: one trained model per species.

* `$predictions`: suitability rasters (`SpatRaster`) for the training area (one per species).

Note that this is not meant to have an ecological relevance: the purpose is to show the data cube structure with suitability values. 

``` {r, echo = TRUE, eval = TRUE}
# Train MaxEnt for each species

sdms <- vsc_create_sdm_for_species_list(
species_list = sp_list,
stack_clima = cl_nld$predictors, # SpatRaster for the training area/month
background_points = 10000, # adjust as needed
predictors = names(cl_nld$predictors),
verbose = TRUE
)

# Inspect outputs
names(sdms)

names(sdms$models)[1:5]

# Quick look at predictions (training area)
terra::plot(terra::rast(sdms$predictions), col = mako(100))
``` 

## Project trained models to a new area (same month/variables)

What this does:
* Builds WorldClim predictors for the new target area (here: Belgium, May)
* Applies each traine model to the new predictor stack
* Returns a `stars` cube with attribute `suit` and dimension `species`.

``` {r, echo = TRUE, eval = TRUE}
# Build predictors for the new area (Belgium, month = 5)
cl_bel <- vsc_build_worldclim(iso3 = "BEL", month = 5)

# Optional sanity check: names must match the training predictors
stopifnot(setequal(names(cl_bel$predictors), names(cl_nld$predictors)))


# Predict: models (from previous chunk) -> new area predictors
pred_bel <- vsc_predict_sdm_for_new_area(
models = sdms$models,
new_stack = cl_bel$predictors
)

``` 

The 3 dimensions are: **x**, **y** and **species**.

``` {r, echo = TRUE, eval = TRUE}
# Inspect the stars output
pred_bel # stars object with attribute "suit"
``` 

## Aggregate species suitability into a polygon grid

After predicting habitat suitability for each species over the new area (Belgium), we can summarize those high-resolution maps into a regular grid.
This step serves three main purposes:

* **compression**: reduces raster resolution so the cube becomes smaller and faster to analyze.

* **comparability**: aligns all species to the same polygon grid, enabling cross-species or cell-wise analysis.

* **interpretability**: each grid cell represents an “average suitability” over that polygon’s extent.

`vsc_make_grid_over()` automatically builds a polygon grid covering the raster extent. You can control either:

`n = c(nx, ny)`: number of grid cells along x and y, or

`cellsize = 0.1`: fixed size in degrees.

Once the grid is created, `aggregate_suitability()` computes the mean suitability of each species within every polygon, producing a compact stars object with:

* one attribute: `suitability`, and

* two dimensions: `cell` (grid polygon) and `species`

Finally, `vsc_plot_raster_with_grid()` overlays the grid on top of one predictor (e.g., tmin) so you can visually inspect the aggregation layout.

``` {r, echo = TRUE, eval = TRUE}
# Make a grid over the new area’s predictor extent (Belgium)
# Option A: pick grid size via number of cells in x,y:
grid_bel <- vsc_make_grid_over(cl_bel$predictors, n = c(50, 50))

# Option B (alternative): fixed cellsize in degrees (e.g. ~0.1°)
grid_bel <- vsc_make_grid_over(cl_bel$predictors, cellsize = 0.1)

# Aggregate the species stars cube (pred_bel) over polygons
agg_bel <- aggregate_suitability(pred_bel, grid_bel, fun = mean)

# output: 
agg_bel
st_dimensions(agg_bel) 
names(agg_bel)

# show a raster layer with the grid on top
vsc_plot_raster_with_grid(cl_bel$predictors[[1]], grid_bel)

``` 

## Inspect species suitability for a specific location

Once the aggregated cube is ready, you can zoom in on a single grid cell — for example, the one containing Brussels — to see how all modeled species perform there.

This diagnostic step helps interpret local suitability patterns, identify species-rich vs. poor cells, and visually compare model outputs.

`vsc_cell_id_for_point()`: finds which polygon (cell) in the grid contains a given longitude–latitude coordinate. Then, `vsc_cell_suitability_long()` extracts all suitability values for that cell and reshapes them into a tidy long table with columns:

* **cell**: polygon ID

* **species**: species name

* **suitability**: aggregated suitability value

`vsc_plot_cell_suitability()` plots these values as a quick bar or point chart, giving a visual “species profile” for that location.

This makes it easy to compare species’ modeled suitability within a single site or to rank locations by potential habitat richness.
``` {r, echo = TRUE, eval = TRUE}
# pick a point (Brussels)
cell_id <- vsc_cell_id_for_point(grid_bel, lon = 4.3517, lat = 50.8503)

# extract long table of suitability per species for that cell
df_long <- vsc_cell_suitability_long(agg_bel, cell_id)
head(df_long)

# Quick plot of species profile for this cell
p_cell <- vsc_plot_cell_suitability(df_long)
p_cell
``` 
